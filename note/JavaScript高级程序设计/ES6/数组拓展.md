### 1. 拓展运算符
+ 含义
拓展运算符(spread)是三个点(...)。它好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列。
```js
  console.log(...[1, 2, 3]) // 1 2 3

  console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5
```
该运算符主要用于函数调用
```js
  function pushf(array, ...items) {
    array.push(...items)
  }

  function add(x, y) {
    return x + y
  }

  const numbers = [4, 38]
  add(...numbers) //42
```
上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们都使用了拓展运算符。该运算符将一个数组，变为参数序列。

拓展运算符与正常的函数参数可以结合使用，非常灵活。
```js
  function f(v, w, x, y, z) {}
  const args = [0, 1]
  f(-1, ...arg, 2, ...[3])
```
拓展运算符后面还可以放置表达式。
```js
  const arr = [
    ...(x > 0 ? ['a'] : []),
    'b'
  ]
```
如果拓展运算符后面是一个空数组，则不产生任何效果。
```js
  [...[], 1] // [1]
```

注意，只有函数调用时，拓展运算符才可以放在圆括号中，否则会报错。
```js
  (...[1, 2])
  // Uncaught SyntaxError: Unexpected number

  console.log((...[1, 2]))
  // Uncaught SyntaxError: Unexpected number

  console.log(...[1, 2])
  // 1 2
```
上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。

### 代替函数的applay()方法
由于拓展运算符可以展开数组，所以不再需要apply()方法将数组转换为函数的参数了。
```js
  // ES5 的写法
  function f(x, y, z) {
    // ...
  }
  var args = [0, 1, 2];
  f.apply(null, args);

  // ES6 的写法
  function f(x, y, z) {
    // ...
  }
  let args = [0, 1, 2];
  f(...args);
```

下面是拓展运算符取代apply()方法的一个实际的例子，用用Math.max()方法，简化求出一个数组最大化元素的写法。
```js
  // ES5 的写法
  Math.max.apply(null, [14, 3, 77])

  // ES6 的写法
  Math.max(...[14, 3, 77])

  // 等同于
  Math.max(14, 3, 77);
```

上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max()函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max()了。

另一个例子是通过push()函数，将一个数组添加到另一个数组的尾部。
```js
  // ES5 的写法
  var arr1 = [0, 1, 2];
  var arr2 = [3, 4, 5];
  Array.prototype.push.apply(arr1, arr2);

  // ES6 的写法
  let arr1 = [0, 1, 2];
  let arr2 = [3, 4, 5];
  arr1.push(...arr2);
```

上面代码的 ES5 写法中，push()方法的参数不能是数组，所以只好通过apply()方法变通使用push()方法。有了扩展运算符，就可以直接将数组传入push()方法。

下面是另外一个例子。
```js
  // ES5
  new (Date.bind.apply(Date, [null, 2015, 1, 1]))

  // ES6
  new Date(...[2015, 1, 1]);
```

### 拓展运算符的应用
+ (1) 赋值数组

数组是符合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。
```js
  const a1 = [1, 2]
  const a2 = a1
  a2[0] = 2
  a1 // [2, 2]
```

上面代码中，a2并不是a1的克隆，而是指向同一份数据集的另一个指针。修改a2，会直接导致a1的变化。
ES5 只能用变通方法来复制数组。
```js
  const a1 = [1, 2]
  const a2 = a1.concat()

  a2[0] = 2
  a1 // [1, 2]
```
上面代码中,a1会返回原数组的克隆，再修改a2就不会对a1产生影响。
拓展运算符提供了复制数组的简便写法。
```js
  const a1 = [1, 2]

  // 写法一
  const a2 = [...a1]
  // 写法二
  const [...a2] = a1
```
上面两种写法，a2都是a1的克隆

+ (2)合并数组

拓展运算符提供了数组合并的新写法。
```js
  const arr1 = ['a', 'b'];
  const arr2 = ['c'];
  const arr3 = ['d', 'e'];

  // ES5 的合并数组
  arr1.concat(arr2, arr3);
  // [ 'a', 'b', 'c', 'd', 'e' ]

  // ES6 的合并数组
  [...arr1, ...arr2, ...arr3]
  // [ 'a', 'b', 'c', 'd', 'e' ]
```

不过这两种方法都是浅拷贝，使用的时候需要注意。
```js
  const a1 = [{ foo: 1 }];
  const a2 = [{ bar: 2 }];

  const a3 = a1.concat(a2);
  const a4 = [...a1, ...a2];

  a3[0] === a1[0] // true
  a4[0] === a1[0] // true
```
上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。

+ (3) 与赋值解构结合

拓展运算符可以与解构赋值结合起来，用于生成数组。
```js
  // ES5
  a = list[0], reset = list.slice(1)

  // ES6
  [a, ...reset] = list
```

下面是另外一些例子。
```js
  const [first, ...rest] = [1, 2, 3, 4, 5];
  first // 1
  rest  // [2, 3, 4, 5]

  const [first, ...rest] = [];
  first // undefined
  rest  // []

  const [first, ...rest] = ["foo"];
  first  // "foo"
  rest   // []
```
如果将拓展运算符用于数组赋值，只能放在参数最后一位，否则会报错。
```js
  const [...butLast, last] = [1, 2, 3, 4, 5];
  // 报错

  const [first, ...middle, last] = [1, 2, 3, 4, 5];
  // 报错
```

+ (4) 字符串
拓展